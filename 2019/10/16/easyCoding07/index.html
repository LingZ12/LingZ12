<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>(七)并发与多线程 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="并发（concurrency）与并行（parallellism）并发是指某个时间段内,多任务交替处理的能力,用TPS和QPS去衡量并发程度。并行指某个时间段内,多任务同时运行的能力 并发程序特点  并发程序之间有相互制约的关系. 并发程序的执行过程是断断续续的. 当并发数设置合理并且CPU拥有足够的而处理能力是,并发会提高程序的运行效率.">
<meta property="og:type" content="article">
<meta property="og:title" content="(七)并发与多线程">
<meta property="og:url" content="http://example.com/2019/10/16/easyCoding07/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="并发（concurrency）与并行（parallellism）并发是指某个时间段内,多任务交替处理的能力,用TPS和QPS去衡量并发程度。并行指某个时间段内,多任务同时运行的能力 并发程序特点  并发程序之间有相互制约的关系. 并发程序的执行过程是断断续续的. 当并发数设置合理并且CPU拥有足够的而处理能力是,并发会提高程序的运行效率.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2019/10/16/easyCoding07/easyCoding07/1.png">
<meta property="og:image" content="http://example.com/2019/10/16/easyCoding07/easyCoding07/2.png">
<meta property="og:image" content="http://example.com/2019/10/16/easyCoding07/easyCoding07/3.png">
<meta property="article:published_time" content="2019-10-16T05:14:47.000Z">
<meta property="article:modified_time" content="2019-10-16T07:26:28.655Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="EasyCoding笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2019/10/16/easyCoding07/easyCoding07/1.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-easyCoding07" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/16/easyCoding07/" class="article-date">
  <time datetime="2019-10-16T05:14:47.000Z" itemprop="datePublished">2019-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      (七)并发与多线程
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>并发（concurrency）与并行（parallellism）</strong><br>并发是指某个时间段内,多任务交替处理的能力,用TPS和QPS去衡量并发程度。<br>并行指某个时间段内,多任务同时运行的能力</p>
<p><strong>并发程序特点</strong></p>
<ol>
<li>并发程序之间有相互制约的关系.</li>
<li>并发程序的执行过程是断断续续的.</li>
<li>当并发数设置合理并且CPU拥有足够的而处理能力是,并发会提高程序的运行效率.</li>
</ol>
<a id="more"></a>

<h2 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1.多线程"></a>1.多线程</h2><h3 id="1-1相关概念"><a href="#1-1相关概念" class="headerlink" title="1.1相关概念"></a>1.1相关概念</h3><p><strong>进程</strong>可以说是操作系统的基础，是程序的一次运行，进程是操作系统进行资源分配和调度的最小单元。</p>
<p><strong>线程</strong>可以理解为进程的一个或多个子任务，如果一个进程只有一个线程，可以理解为单任务进程，单任务的特点就行排队执行，也就是同步。使用多线程的目的就是在线程安全的情况下进行异步执行，尽可能的提高CPU及系统资源的利用率，这也是其优点。</p>
<p><strong>多线程</strong>：进程和线程是一对多的关系，一个进程（一个程序），由不同的线程来运行。有共享的空间也有独立的空间。</p>
<p><strong>TPS</strong>：Transactions Per Second（每秒传输的事物处理个数），简单说就是服务器每秒处理事务的个数。完整的包括: 请求+数据库访问+响应</p>
<p><strong>QPS</strong>：Queries Per Second（每秒查询率），简单说就是服务器每秒处理完请求的个数。</p>
<h3 id="1-2线程状态图"><a href="#1-2线程状态图" class="headerlink" title="1.2线程状态图"></a>1.2线程状态图</h3><p><img src="easyCoding07/1.png" alt="线程状态图"></p>
<ol>
<li>NEW,即新建状态,是线程被创建且未启动的状态</li>
<li>RUNNABLE,即就绪状态,是调用start()之后运行之前的状态</li>
<li>RUNNING,即运行状态,是run()正在主席那个时线程的状态</li>
<li>BLOCKED,即阻塞状态,进入此状态,有以下情况<br>(1).同步阻塞:锁被其他线程占用<br>(2).调用Thread的某些方法,主动让出CPU执行权,比如sleep().join()等<br>(3).等待阻塞:执行了wait()</li>
<li>DEAD,即终止状态,时run()执行结束,或因异常退出后的状态,此状态不可逆转</li>
</ol>
<h2 id="2-线程的创建"><a href="#2-线程的创建" class="headerlink" title="2.线程的创建"></a>2.线程的创建</h2><p>线程创建主要有三种方式</p>
<ol>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
</ol>
<h3 id="2-1-重写Thread的run方法"><a href="#2-1-重写Thread的run方法" class="headerlink" title="2.1 重写Thread的run方法"></a>2.1 重写Thread的run方法</h3><p>查看Thread类的源码，可以发现它实现了Runnable接口，然后在自己的run方法中调用了Runnable的run方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread thread &#x3D; new Thread()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
<h3 id="2-2通过Runnable的run方法"><a href="#2-2通过Runnable的run方法" class="headerlink" title="2.2通过Runnable的run方法"></a>2.2通过Runnable的run方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread thread &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
<h3 id="2-3通过Callable接口call方法"><a href="#2-3通过Callable接口call方法" class="headerlink" title="2.3通过Callable接口call方法"></a>2.3通过Callable接口call方法</h3><p>通过Callable<T>接口实现多线程，比较繁琐，优点是有返回值。<br>创建一个类实现Callable<T>接口，其中泛型为返回的值的类型、然后实现Callable的call方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void callableThreadTest()&#123;</span><br><span class="line"></span><br><span class="line">        CallableThread callableThread &#x3D; new CallableThread();</span><br><span class="line">        FutureTask&lt;String&gt; stringFutureTask &#x3D; new FutureTask&lt;&gt;(callableThread);</span><br><span class="line">        Thread thread &#x3D; new Thread(stringFutureTask);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 这种实现是由返回值的</span><br><span class="line">     *&#x2F;</span><br><span class="line">    class CallableThread implements Callable&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String call() &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO: 2018&#x2F;8&#x2F;31</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-线程的阻塞"><a href="#3-线程的阻塞" class="headerlink" title="3.线程的阻塞"></a>3.线程的阻塞</h2><h3 id="3-1-join-合并线程"><a href="#3-1-join-合并线程" class="headerlink" title="3.1 join 合并线程"></a>3.1 join 合并线程</h3><p>join可以理解为合并的意思，将多条线程合并为一条。下面是join的几个重载</p>
<p>join()：等待该线程终止<br>join(long millis)：等待该线程终止的时间最长为millis毫秒<br>join(long millis, int nanos)：等待该线程终止的时间最长为millis毫秒+nanos纳秒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Thread1 extends Thread&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100 ; i++) &#123;</span><br><span class="line">            System.out.println(&quot;join...&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Thread1 thread1 &#x3D; new Thread1();</span><br><span class="line">        Thread t &#x3D; new Thread(thread1); &#x2F;&#x2F;新生</span><br><span class="line">        t.start();  &#x2F;&#x2F;就绪</span><br><span class="line">        &#x2F;&#x2F;cpu调度后则进入运行状态</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100 ; i++) &#123;</span><br><span class="line">            if (i&#x3D;&#x3D;50)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    t.join();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;main...&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">join...0</span><br><span class="line">main...0</span><br><span class="line">join...1</span><br><span class="line">main...1</span><br><span class="line">join...2</span><br><span class="line">main...2</span><br><span class="line">...</span><br><span class="line">main...48</span><br><span class="line">join...49</span><br><span class="line">main...49</span><br><span class="line">join...50</span><br><span class="line">join...51</span><br><span class="line">join...52</span><br><span class="line">...</span><br><span class="line">join...97</span><br><span class="line">join...98</span><br><span class="line">join...99</span><br><span class="line">main...50</span><br><span class="line">main...51</span><br><span class="line">main...52</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>查看运行结果，会发现。在执行join之前，main线程与 t 线程是多线程同时执行的。而当执行了t的join方法之后，等到 t 线程执行完后，main线程才继续执行。也就是在 t 线程执行的过程中，main线程被阻塞了。等到 t 线程执行完，main线程才继续执行。</p>
<h3 id="3-2-yield-暂停线程"><a href="#3-2-yield-暂停线程" class="headerlink" title="3.2 yield 暂停线程"></a>3.2 yield 暂停线程</h3><p>yield方法可以实现暂停当前线程，执行其他的线程。它是一个static方法，暂停的具体线程取决于它执行的地方。<br>yield()方法没有参数</p>
<h3 id="3-3-sleep-休眠线程"><a href="#3-3-sleep-休眠线程" class="headerlink" title="3.3 sleep 休眠线程"></a>3.3 sleep 休眠线程</h3><p>sleep方法可以让当前正在执行的线程进行休眠一定秒数。</p>
<p>sleep(long millis)：让当前线程休眠millis毫秒<br>join(long millis, int nanos)：让当前线程休眠millis毫秒+nanos纳秒</p>
<p>每一个对象都有一把锁。当该线程休眠的时候，不会释放锁。</p>
<p>sleep可以有以下的作用：</p>
<ol>
<li>与时间相关：倒计时</li>
<li>模拟网络延时</li>
</ol>
<h2 id="4-线程的同步"><a href="#4-线程的同步" class="headerlink" title="4.线程的同步"></a>4.线程的同步</h2><p>同步也称为并发。由于现在有多个线程，就可能导致多个线程访问同一份资源的问题。我们要确保这个资源安全，因此我们对其进行同步的处理。这样就可以保证它线程安全。<br>也就是说，线程安全的资源就是指多个线程同时访问这个资源的时候，是同步的。这份资源是安全的。</p>
<p>概念介绍</p>
<p><strong>原子性</strong><br>原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作是原子操作。 比如：a++； 这个操作实际是a = a + 1；是可分割的 ，因此它不是原子操作。<br>非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。<br>在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。 </p>
<p><strong>可见性</strong><br>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。 也就是一个线程修改的结果。另一个线程马上就能看到。</p>
<p>用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。</p>
<p>需要注意的是，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。</p>
<p>在 Java 中 volatile、synchronized 和 final 实现可见性。 </p>
<p><strong>有序性</strong><br>Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。</p>
<h3 id="4-1synchronized关键字"><a href="#4-1synchronized关键字" class="headerlink" title="4.1synchronized关键字"></a>4.1synchronized关键字</h3><p>我们通过synchronized标识符可以保证某一部分的线程安全，它是通过等待来实现的。我们把使用synchronized的行为叫做‘加锁’。当几个线程同时访问一份资源的时候，先到达的线程拿到锁，然后再轮到其他线程来。这样能保证线程的安全。</p>
<p>当我们加上synchronized后，就是为它加了一把锁。当多个线程同时来访问这份资源时，先到达的资源便可以得到这个锁，其他资源只能等待，等待结束后再执行。这样就保证了我们的线程安全。</p>
<p>由于线程安全是通过等待来进行，因此会造成效率的低下。为了减少这种效率损耗，我们应该尽量缩小加锁的范围，来提高效率。</p>
<p><strong>同步块</strong><br>我们都知道，{}及里面的语句表示一个同步块。在它前面加上synchronized(引用类型)标识符，就变成了一个同步块。</p>
<p>而synchronized锁 类.class 时，比较特殊。主要是用于给一些静态的对象加锁。(如线程安全的单例模式就会用到)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(引用类型|this|类.class)&#123;</span><br><span class="line">    &#x2F;&#x2F;TODO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同步方法</strong><br>在方法的前面加上synchronized，就称这个方法是同步方法。</p>
<h3 id="4-2Lock接口"><a href="#4-2Lock接口" class="headerlink" title="4.2Lock接口"></a>4.2Lock接口</h3><p>在Java SE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要 显式 地获取和释放锁。<br>虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的 可操作性、可中断的获取锁 以及 超时获取锁 等多种synchronized关键字所不具备的同步特性。</p>
<p>使用synchronized关键字将会 隐式 地获取锁，但是它将锁的获取和释放固化了，也就是先获取再释放。</p>
<p>Lock的使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 ：</p>
<p>1.在finally块中释放锁，目的是保证在获取到锁之后，最终能够被释放。<br>2.不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。</p>
<p>Lock接口提供的synchronized关键字所不具备的主要特性：</p>
<ul>
<li>尝试非阻塞性获取锁： 当前线程尝试获取锁，如果此时没有其他线程占用此锁，则成功获取到锁。</li>
<li>能被中断的获取锁： 当获取到锁的线程被中断时，中断异常会抛出并且会释放锁。</li>
<li>超时获取锁： 在指定时间内获取锁，如果超过时间还没获取，则返回。</li>
</ul>
<p>Lock 相关的API：</p>
<ul>
<li>void lock();：获取锁，获取之后返回</li>
<li>void lockInterruptibly() throws InterruptedException;：可中断的获取锁</li>
<li>boolean tryLock();：尝试非阻塞的获取锁</li>
<li>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;： 超时获取锁。 超时时间结束，未获得锁，返回false.</li>
<li>void unlock();：释放锁</li>
<li>Condition newCondition();：获取等待通知组件，改组件和锁绑定，当前线程获取到锁才能调用wait()方法，调用之后则会释放锁。</li>
</ul>
<h3 id="4-3volatile关键字"><a href="#4-3volatile关键字" class="headerlink" title="4.3volatile关键字"></a>4.3volatile关键字</h3><p>线程对于普通的共享对象的操作发生在本地内存中，有时可能来不及同步到主内存中，就开始了下一个线程的处理。因此我们就可以用volatile来保证这个共享对象的可见性，强制将内存刷新到主内存中。</p>
<p>volatile具备两种特性，第一就是保证共享变量对所有线程的可见性。将一个共享变量声明为volatile后，会有以下效应：</p>
<p>1.当写一个volatile变量时，JMM(java内存模型)会把该线程对应的本地内存中的变量强制刷新到主内存中去；</p>
<p>2.这个写会操作会导致其他线程中的缓存无效。</p>
<h3 id="4-4信号量"><a href="#4-4信号量" class="headerlink" title="4.4信号量"></a>4.4信号量</h3><p>介绍之前讲到线程锁，一个线程如果锁定了一资源，那么其它线程只能等待资源的释放。也就是一次只有一个线程执行，直到这个线程执行完毕或者unlock。而**信号量(Semaphore)**可以控制多个线程同时对某个资源的访问。</p>
<p>**信号量(Semaphore)**是用来保护一个或者多个共享资源的访问，Semaphore内部维护了一个计数器，其值为可以访问的共享资源的个数。一个线程要访问共享资源，先获得信号量，如果信号量的计数器值大于1，意味着有共享资源可以访问，则使其计数器值减去1，再访问共享资源。</p>
<p>就好比一个厕所管理员，站在门口。如果有厕所有空位，就开门允许与空厕数量等量的人进入厕所。多个人进入厕所后，相当于N个人来分配使用N个空位。为了避免多个人来同时竞争同一个厕所，在内部仍然使用锁来控制资源的同步访问。<br>使用</p>
<p>Semaphore使用时需要先构建一个参数来指定共享资源的数量，Semaphore构造完成后即可获取Semaphore。共享资源使用完毕后释放Semaphore。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore &#x3D; new Semaphore(10,true);</span><br><span class="line">semaphore.acquire();</span><br><span class="line">&#x2F;&#x2F;TODO</span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure>
<p>比如下面的代码就是模拟控制一个商场厕所的并发使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">public class ResourceManage &#123;  </span><br><span class="line">    private final Semaphore semaphore ;  </span><br><span class="line">    private boolean resourceArray[];  </span><br><span class="line">    private final ReentrantLock lock;  </span><br><span class="line">    public ResourceManage() &#123;  </span><br><span class="line">        this.resourceArray &#x3D; new boolean[10];&#x2F;&#x2F;存放厕所状态  </span><br><span class="line">        this.semaphore &#x3D; new Semaphore(10,true);&#x2F;&#x2F;控制10个共享资源的使用，使用先进先出的公平模式进行共享（公平模式的信号量，先来的先获得信号量）  </span><br><span class="line">        this.lock &#x3D; new ReentrantLock(true);&#x2F;&#x2F;公平模式的锁，先来的先选  </span><br><span class="line">        for(int i&#x3D;0;i&lt;10; i++)&#123;  </span><br><span class="line">            resourceArray[i] &#x3D; true;&#x2F;&#x2F;初始化为资源可用的情况  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void useResource(int userId)&#123; </span><br><span class="line">        semaphore.acquire(); </span><br><span class="line">        try&#123;  </span><br><span class="line">            int id &#x3D; getResourceId();&#x2F;&#x2F;占到一个坑  </span><br><span class="line">            System.out.print(&quot;userId:&quot;+userId+&quot;正在使用资源，资源id:&quot;+id+&quot;\n&quot;);  </span><br><span class="line">            Thread.sleep(100);&#x2F;&#x2F;do something，相当于于使用资源  </span><br><span class="line">            resourceArray[id] &#x3D; true;&#x2F;&#x2F;退出这个坑  </span><br><span class="line">        &#125;catch (InterruptedException e)&#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;finally &#123;  </span><br><span class="line">            semaphore.release();&#x2F;&#x2F;释放信号量，计数器加1  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    private int getResourceId()&#123;  </span><br><span class="line">        int id &#x3D; -1; </span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;  </span><br><span class="line">            &#x2F;&#x2F;虽然使用了锁控制同步，但由于只是简单的一个数组遍历，效率还是很高的，所以基本不影响性能。  </span><br><span class="line">            for(int i&#x3D;0; i&lt;10; i++)&#123;  </span><br><span class="line">                if(resourceArray[i])&#123;  </span><br><span class="line">                    resourceArray[i] &#x3D; false;  </span><br><span class="line">                    id &#x3D; i;  </span><br><span class="line">                    break;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;catch (Exception e)&#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;finally &#123;  </span><br><span class="line">            lock.unlock();  </span><br><span class="line">        &#125;  </span><br><span class="line">        return id;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">public class ResourceUser implements Runnable&#123;  </span><br><span class="line">    private ResourceManage resourceManage;  </span><br><span class="line">    private int userId;  </span><br><span class="line">    public ResourceUser(ResourceManage resourceManage, int userId) &#123;  </span><br><span class="line">        this.resourceManage &#x3D; resourceManage;  </span><br><span class="line">        this.userId &#x3D; userId;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void run()&#123;  </span><br><span class="line">        System.out.print(&quot;userId:&quot;+userId+&quot;准备使用资源...\n&quot;);  </span><br><span class="line">        resourceManage.useResource(userId);  </span><br><span class="line">        System.out.print(&quot;userId:&quot;+userId+&quot;使用资源完毕...\n&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args)&#123;  </span><br><span class="line">        ResourceManage resourceManage &#x3D; new ResourceManage();  </span><br><span class="line">        Thread[] threads &#x3D; new Thread[100];  </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i++) &#123;  </span><br><span class="line">            Thread thread &#x3D; new Thread(new ResourceUser(resourceManage,i));&#x2F;&#x2F;创建多个资源使用者  </span><br><span class="line">            threads[i] &#x3D; thread;  </span><br><span class="line">        &#125;  </span><br><span class="line">        for(int i &#x3D; 0; i &lt; 100; i++)&#123;  </span><br><span class="line">            Thread thread &#x3D; threads[i];  </span><br><span class="line">            try &#123;  </span><br><span class="line">                thread.start();&#x2F;&#x2F;启动线程  </span><br><span class="line">            &#125;catch (Exception e)&#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure>
<h2 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5.线程池"></a>5.线程池</h2><h3 id="5-1-使用线程池的好处"><a href="#5-1-使用线程池的好处" class="headerlink" title="5.1 使用线程池的好处"></a>5.1 使用线程池的好处</h3><p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。<br>第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源,还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p>
<h3 id="5-2线程池实现原理"><a href="#5-2线程池实现原理" class="headerlink" title="5.2线程池实现原理"></a>5.2线程池实现原理</h3><p>图解<br><img src="easyCoding07/2.png"><br>代码<br><img src="easyCoding07/3.png"></p>
<h3 id="5-2线程池的使用"><a href="#5-2线程池的使用" class="headerlink" title="5.2线程池的使用"></a>5.2线程池的使用</h3><h4 id="5-2-1创建线程池"><a href="#5-2-1创建线程池" class="headerlink" title="5.2.1创建线程池"></a>5.2.1创建线程池</h4><p>我们可以通过ThreadPoolExecutor构造方法来创建一个线程池。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1）corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，如果当前poolSize&lt;corePoolSize时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</p>
<p>2）maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。</p>
<p>3）keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</p>
<p>4）TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</p>
<p>5）runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。</p>
<pre><code>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。

LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。

SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。

PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</code></pre>
<p>6）ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线<br>程设置有意义的名字，代码如下。<br>new ThreadFactoryBuilder().setNameFormat(“XX-task-%d”).build();</p>
<p>7）RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。<br>    AbortPolicy：直接抛出异常。<br>    CallerRunsPolicy：只用调用者所在线程来运行任务。<br>    DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。<br>    DiscardPolicy：不处理，丢弃掉。<br>    当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。</p>
<h4 id="5-2-2向线程池提交任务"><a href="#5-2-2向线程池提交任务" class="headerlink" title="5.2.2向线程池提交任务"></a>5.2.2向线程池提交任务</h4><p>可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。这两个方法的区别就是，execute()用于提交不需要返回值的任务，submit()方法用于提交需要返回值的任务。</p>
<p><strong>execute方法：</strong><br>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.execute(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>submit方法：</strong><br>线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方<br>法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future &#x3D; executor.submit(haveReturnValuetask);</span><br><span class="line">try &#123;</span><br><span class="line">Object s &#x3D; future.get();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">&#x2F;&#x2F; 处理中断异常</span><br><span class="line">&#125; catch (ExecutionException e) &#123;</span><br><span class="line">&#x2F;&#x2F; 处理无法执行任务异常</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">&#x2F;&#x2F; 关闭线程池</span><br><span class="line">executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-3关闭线程池"><a href="#5-2-3关闭线程池" class="headerlink" title="5.2.3关闭线程池"></a>5.2.3关闭线程池</h4><p>可以通过调用线程池的<strong>shutdown或shutdownNow</strong>方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。<br>只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p>
<h4 id="5-2-4实例Demo"><a href="#5-2-4实例Demo" class="headerlink" title="5.2.4实例Demo"></a>5.2.4实例Demo</h4><p>（1）首先构造一个线程池，用ArrayBlockingQueue作为其等待队列，队列初始化容量为1。该线程池核心容量为 10，最大容量为20，线程存活时间为1分钟。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static BlockingQueue blockingQueue&#x3D;new ArrayBlockingQueue&lt;&gt;(1);</span><br><span class="line">static ThreadPoolExecutor threadPoolExecutor&#x3D;new ThreadPoolExecutor(10, 20, 1, TimeUnit.MINUTES, blockingQueue);</span><br></pre></td></tr></table></figure>
<p>（2）另外构造了一个实现Runable接口的类TaskBusyWithoutResult类，其模拟一个繁忙的任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static class TaskBusyWithoutResult implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    public TaskBusyWithoutResult()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() </span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;线程&quot;+Thread.currentThread()+&quot;开始运行&quot;);</span><br><span class="line">        int i&#x3D;10000*10000;</span><br><span class="line">        while(i&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;线程&quot;+Thread.currentThread()+&quot;运行结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）向线程池提交20个任务，执行任务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">        Runnable runnable &#x3D; new TaskBusyWithoutResult();</span><br><span class="line">        threadPoolExecutor.submit(runnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>java面试题之什么是线程ThreadLocal？作用是什么?</strong></p>
<p>定义：线程局部变量是局限于线程内的变量，属于线程自身所有，不在多个线程间共享。java提供ThreadLocal类来支持线程局部变量，是一个实现线程安全的方式。</p>
<p>任何线程局部变量一旦在工作完成后没有释放，java应用就存在内存泄露的风险</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/16/easyCoding07/" data-id="ckk5bkaei001idkgdcri9blu6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/EasyCoding%E7%AC%94%E8%AE%B0/" rel="tag">EasyCoding笔记</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/10/17/Mybatis-Pagehelper/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Mybatis-Pagehelper使用总结
        
      </div>
    </a>
  
  
    <a href="/2019/10/14/easyCoding06/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">(六)数据结构与集合</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/EasyCoding%E7%AC%94%E8%AE%B0/" rel="tag">EasyCoding笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lambda/" rel="tag">Lambda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PageHelper/" rel="tag">PageHelper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stream/" rel="tag">Stream</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/idea/" rel="tag">idea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">java设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/" rel="tag">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssm%E9%85%8D%E7%BD%AE/" rel="tag">ssm配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81sql/" rel="tag">动态sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" rel="tag">设计原则</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/EasyCoding%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">EasyCoding笔记</a> <a href="/tags/Lambda/" style="font-size: 10px;">Lambda</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Mybatis/" style="font-size: 15px;">Mybatis</a> <a href="/tags/PageHelper/" style="font-size: 10px;">PageHelper</a> <a href="/tags/Stream/" style="font-size: 10px;">Stream</a> <a href="/tags/idea/" style="font-size: 10px;">idea</a> <a href="/tags/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">java设计模式</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/ssm%E9%85%8D%E7%BD%AE/" style="font-size: 10px;">ssm配置</a> <a href="/tags/%E5%8A%A8%E6%80%81sql/" style="font-size: 10px;">动态sql</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" style="font-size: 10px;">设计原则</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/20/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/06/06/Mybatis-Base/">MyBatis知识点总结(一)</a>
          </li>
        
          <li>
            <a href="/2020/01/28/Lambda/">Lambda学习总结</a>
          </li>
        
          <li>
            <a href="/2020/01/27/Stream/">Stream流学习总结</a>
          </li>
        
          <li>
            <a href="/2020/01/18/Algorithm-summary/">算法总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>