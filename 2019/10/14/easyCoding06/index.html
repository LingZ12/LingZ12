<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>(六)数据结构与集合 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.数据结构1.1 数据结构的定义数据结构是指逻辑意义上的数据组织方式及其相应的处理方式. 数据组织方式:树: 二叉树, 三叉树, B+ 树等;图: 有向图, 无向图;队列: 先进先出的线性结构;哈希: 根据某种算法直接定位的数据组织方式;">
<meta property="og:type" content="article">
<meta property="og:title" content="(六)数据结构与集合">
<meta property="og:url" content="http://example.com/2019/10/14/easyCoding06/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.数据结构1.1 数据结构的定义数据结构是指逻辑意义上的数据组织方式及其相应的处理方式. 数据组织方式:树: 二叉树, 三叉树, B+ 树等;图: 有向图, 无向图;队列: 先进先出的线性结构;哈希: 根据某种算法直接定位的数据组织方式;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2019/10/14/easyCoding06/easyCoding06/1.png">
<meta property="article:published_time" content="2019-10-14T11:55:42.000Z">
<meta property="article:modified_time" content="2019-10-17T09:36:49.853Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="EasyCoding笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2019/10/14/easyCoding06/easyCoding06/1.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-easyCoding06" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/14/easyCoding06/" class="article-date">
  <time datetime="2019-10-14T11:55:42.000Z" itemprop="datePublished">2019-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      (六)数据结构与集合
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h2><h3 id="1-1-数据结构的定义"><a href="#1-1-数据结构的定义" class="headerlink" title="1.1 数据结构的定义"></a>1.1 数据结构的定义</h3><p>数据结构是指逻辑意义上的数据组织方式及其相应的处理方式.</p>
<p>数据组织方式:<br>树: 二叉树, 三叉树, B+ 树等;<br>图: 有向图, 无向图;<br>队列: 先进先出的线性结构;<br>哈希: 根据某种算法直接定位的数据组织方式;</p>
<a id="more"></a>

<p>**数据处理方式: **在既定的数据组织方式上, 以某种特定的算法实现数据的增删改查和遍历. 不同数据处理方式存在巨大的性能差异;</p>
<h3 id="1-2-数据结构分类"><a href="#1-2-数据结构分类" class="headerlink" title="1.2.数据结构分类"></a>1.2.数据结构分类</h3><p>线性结构: 0至1个直接前继和直接后继;包括顺序表、链表、栈、队列等,栈和队列是访问受限的结构; 栈是 LIFO (Last-In, First-Out), 队列是FIFO (First-In, First-Out);</p>
<p>树结构: 0至1个直接前继和 0至n个直接后继(n大于或等于2);结构稳定均衡;</p>
<p>图结构: 0 至n 个直接前继和直接后继（ n大于或等于2 ）;</p>
<p>哈希结构: 没有直接前继和直接后继;通过某种特定的哈希行数将索引与存储的值关联起来; 查找效率非常高;</p>
<p>数据结构复杂度: 空间复杂度, 时间复杂度; 算法时间复杂度是衡量计算性能的指标</p>
<h2 id="2-集合框架"><a href="#2-集合框架" class="headerlink" title="2.集合框架"></a>2.集合框架</h2><p><img src="easyCoding06/1.png" alt="集合框架图"></p>
<h3 id="2-1-List集合"><a href="#2-1-List集合" class="headerlink" title="2.1 List集合"></a>2.1 List集合</h3><p>线性数据结构; ArrayList和LinkedList;<br>ArrayList 容量可变, 非线程安全集合;扩容问题(内部使用数组进行存储, 集合扩容时会创建更大的数组空间, 把原有的数据复制到新数组中); 插入删除数据慢(因为过程中可能需要移动其他元素), 但是索引数据快;<br>LinkedList 是双向链表;相比ArrayList, 插入删除速度快, 随机访问速度慢;</p>
<h3 id="2-2-Queue集合"><a href="#2-2-Queue集合" class="headerlink" title="2.2 Queue集合"></a>2.2 Queue集合</h3><p>队列是以中先进先出的数据结构; FIFO , 一端获取一端插入数据, 特殊线性表;<br>BlockingQueue (阻塞队列),经常被用作Buffer(数据缓冲区使用)</p>
<h3 id="2-3-Map-集合"><a href="#2-3-Map-集合" class="headerlink" title="2.3 Map 集合"></a>2.3 Map 集合</h3><p>K-V键值对为存储元素实现的哈希结构; K 唯一,V 可重复;<br>keySet() 查看所有K, values() 查看所有V, entrySet() 查看所有K-V;<br>最早的Hashtable已经被淘汰(因性能瓶颈);<br>HashMap 线程不安全;ConcurrentMap 线程安全(并发包);<br>TreeMap 是Key有序的Map集合</p>
<h3 id="2-4-Set-集合"><a href="#2-4-Set-集合" class="headerlink" title="2.4 Set 集合"></a>2.4 Set 集合</h3><p>Set 不允许出现重复元素;<br>HashSet 从源码分析是使用HashMap事项, Value 固定为一个静态对象, Key 保证元素唯一, 不保证顺序;<br>TreeSet 由TreeMap实现; 树结构, 保证集合顺序;<br>LinkedHashSet 继承 HashSet; 内部使用链表维护元素插入顺序;</p>
<h2 id="3-集合初始化"><a href="#3-集合初始化" class="headerlink" title="3.集合初始化"></a>3.集合初始化</h2><p>初始化通常进行内存分配、设置特定参数等工作;</p>
<p>ArrayList 默认为10个容量; 每次扩容调用Array.copyOf(), 创建新数组再复制; 创建对象就直接分配大小避免额外开销;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   &#x2F;**</span><br><span class="line">    * Default initial capacity.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private static final int DEFAULT_CAPACITY &#x3D; 10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;扩容计算</span><br><span class="line">int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1)</span><br></pre></td></tr></table></figure>
<p>HashMap 的 Capacity 决定了存储容量大小, 默认16; Load Factor 决定填充比例, 默认0.75; 基于这两个的乘积, HashMap 内部用threshold存储</p>
<p>HashMap 容量不会在new的时候分配, 而是在第一次put后创建;</p>
<p>HashMap 容量大于2的幂;</p>
<h2 id="4-数组与集合"><a href="#4-数组与集合" class="headerlink" title="4.数组与集合"></a>4.数组与集合</h2><p>数组是一种顺序表. 在Java体系中数组用于存储同一类型的对象; 一旦分配内存不可扩容;</p>
<p>对于动态大小的数组, 集合提供了 Vector (线程安全, 但性能较差, 已启用) 和 ArrayList (线程不安全);</p>
<p>数组遍历推荐jdk1.5引进的foreach方式; 也可使用jdk8 的lambda遍历;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; datas &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">   &#x2F;&#x2F;遍历</span><br><span class="line">   datas.forEach(item-&gt;&#123;System.out.println(item);&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="4-1针对数组对象操作的工具类-Arrays"><a href="#4-1针对数组对象操作的工具类-Arrays" class="headerlink" title="4.1针对数组对象操作的工具类: Arrays;"></a>4.1针对数组对象操作的工具类: Arrays;</h3><p>数组转集合: Arrays.asList(); 适配器模式; 返回的是Arrays的内部类, 即修改(set)集合(list)元素, 原数组元素也随之改变 , 但没有实现修改集合个数(add/remove/clear)的相关方法, 抛出UnsuppotedOperationException;<br>    public static <T> List<T> asList(T… a) {<br>        // 此处 ArrayList 为Arrays的一个内部类, 并非java.util.ArrayList<br>        return new ArrayList&lt;&gt;(a);<br>    }</p>
<p>避免修改问题:<br>List<Object> objectList = new java.util.ArrayList<Object>(Arrays.asList(数组));<br>集合转数组: toArray(T[] array) ; 注意传入类型T一致 (数组长度小于集合长度问题)</p>
<h2 id="5-集合与泛型"><a href="#5-集合与泛型" class="headerlink" title="5.集合与泛型"></a>5.集合与泛型</h2><p>List、List<Object>、List&lt;?&gt;</p>
<ul>
<li>List ：完全没有类型限制和赋值限定。</li>
<li>List<Object> ：看似用法与List一样，但是在接受其他泛型赋值时会出现编译错误。例:List<Integer> aint = new ArrayList<Integer>();//编译报错Type mismatch: cannot convert from List<Integer> to List<Object></li>
<li>List<?>：是一个泛型，在没有赋值前，表示可以接受任何类型的集合赋值，但赋值之后不能往里面随便添加元素，但可以remove和clear，并非immutable(不可变)集合。List<?>一般作为参数来接收外部集合，或者返回一个具体元素类型的集合，也称为通配符集合。</li>
</ul>
<p><strong>&lt;? extends T&gt;与&lt;? super T&gt;</strong><br>List 最大的问题是只能放置一种类型，如果随意转变类型的话，就是破窗理论，泛型就失去了意义。为了放置多种受泛型约束的类型，出现了 &lt;? extends T&gt;与&lt;? super T&gt; 两种语法。简单来说， &lt;? extends T&gt; 是Get First，适用于，消费集合元素的场景；&lt;? super T&gt;是Put First，适用于，生产集合元素为主的场景。</p>
<? extends T> ：可以赋值给任意T及T的子类集合，上界为T，取出来的类型带有泛型限制，向上强制转型为T。null 可以表示任何类型，所以null除外，任何元素都不得添加进<? extends T>集合内。

<? super T> : 可以赋值T及任何T的父类集合，下界为T。再生活中，投票选举类似于<? super T>的操作。选举投票时，你只能往里投票，取数据时，根本不知道时是谁的票，相当于泛型丢失。

<? extends T>的场景是put功能受限，而<? super T>的场景是get功能受限。

## 6 元素的比较 Comparable和Comparator
### 1、Comparable
1.1 说明
Comparable可以认为是一个内比较器，实现了Comparable接口的类有一个特点，就是这些 类是可以和自己比较的，至于具体和另一个实现了Comparable接口的类如何比较，则依赖compareTo方法的实现，compareTo方法也被称为自然比较方法。如果开发者add进入一个Collection的对象想要Collections的sort方法帮你自动进行排序的话，那么这个对象必须实现Comparable接口。compareTo方法的返回值是int，有三种情况：-1,0,1  
升序 this.age-s.sge   降序s.age-this.age

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class Student implements Comparable&lt;Student&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    </span><br><span class="line">    public Student(String name,int age)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Student s) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        return this.age-s.age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return name+&quot;:&quot;+age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;Student&gt; students &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        students.add(new Student(&quot;ouym1&quot;,20));</span><br><span class="line">        students.add(new Student(&quot;ouym2&quot;,22));</span><br><span class="line">        students.add(new Student(&quot;ouym3&quot;,21));</span><br><span class="line">        for(Student s : students)&#123;</span><br><span class="line">            System.out.println(s.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;---------------sort--------------&quot;);</span><br><span class="line">        Collections.sort(students);</span><br><span class="line">        for(Student s : students)&#123;</span><br><span class="line">            System.out.println(s.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">复制代码</span><br><span class="line">ouym1:20</span><br><span class="line">ouym2:22</span><br><span class="line">ouym3:21</span><br><span class="line">---------------sort--------------</span><br><span class="line">ouym1:20</span><br><span class="line">ouym3:21</span><br><span class="line">ouym2:22</span><br></pre></td></tr></table></figure>
### 2、Comparator
2.1 说明
Comparator可以认为是是一个外比较器，个人认为有两种情况可以使用实现Comparator接口的方式：
1、一个对象不支持自己和自己比较（没有实现Comparable接口），但是又想对两个对象进行比较。
2、一个对象实现了Comparable接口，但是开发者认为compareTo方法中的比较方式并不是自己想要的那种比较方式。
Comparator接口里面有一个compare方法，方法有两个参数T o1和T o2，是泛型的表示方式，分别表示待比较的两个对象，方法返回值和Comparable接口一样是int，有三种情况：o1大于o2，返回正整数;2、o1等于o2，返回0; 3、o1小于o3，返回负整数

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; stus &#x3D; new ArrayList&lt;Student&gt;()&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				add(new Student(&quot;张三&quot;, 30));	</span><br><span class="line">				add(new Student(&quot;李四&quot;, 20));	</span><br><span class="line">				add(new Student(&quot;王五&quot;, 60));	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		&#x2F;&#x2F;对users按年龄进行排序</span><br><span class="line">		Collections.sort(stus, new Comparator&lt;Student&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			@Override</span><br><span class="line">			public int compare(Student s1, Student s2) &#123;</span><br><span class="line">				&#x2F;&#x2F; 升序</span><br><span class="line">				&#x2F;&#x2F;return s1.getAge()-s2.getAge();</span><br><span class="line">				return s1.getAge().compareTo(s2.getAge());</span><br><span class="line">				&#x2F;&#x2F; 降序</span><br><span class="line">				&#x2F;&#x2F; return s2.getAge()-s1.getAge();</span><br><span class="line">				&#x2F;&#x2F; return s2.getAge().compareTo(s1.getAge());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		&#x2F;&#x2F; 输出结果</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>
Lambada表达式
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; stus &#x3D; new ArrayList&lt;Student&gt;()&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			add(new Student(&quot;张三&quot;, 30));	</span><br><span class="line">			add(new Student(&quot;李四&quot;, 20));	</span><br><span class="line">			add(new Student(&quot;王五&quot;, 60));	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	&#x2F;&#x2F;对users按年龄进行排序</span><br><span class="line">	Collections.sort(stus, (s1,s2)-&gt;(s1.getAge()-s2.getAge()));</span><br></pre></td></tr></table></figure>
多条件排序
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; stus &#x3D; new ArrayList&lt;Student&gt;()&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				add(new Student(&quot;张三&quot;, 30, 1));	</span><br><span class="line">				add(new Student(&quot;李四&quot;, 20, 2));	</span><br><span class="line">				add(new Student(&quot;王五&quot;, 40, 3));	</span><br><span class="line">				add(new Student(&quot;赵六&quot;, 30, 4));	</span><br><span class="line">				add(new Student(&quot;陈七&quot;, 40, 5));	</span><br><span class="line">				add(new Student(&quot;周八&quot;, 20, 6));	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Collections.sort(stus,new Comparator&lt;Student&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			@Override</span><br><span class="line">			public int compare(Student s1, Student s2) &#123;</span><br><span class="line">				int flag;</span><br><span class="line">				&#x2F;&#x2F; 首选按年龄升序排序</span><br><span class="line">				flag &#x3D; s1.getAge()-s2.getAge();</span><br><span class="line">				if(flag&#x3D;&#x3D;0)&#123;</span><br><span class="line">					&#x2F;&#x2F; 再按学号升序排序</span><br><span class="line">					flag &#x3D; s1.getNum()-s2.getNum();</span><br><span class="line">				&#125;</span><br><span class="line">				return flag;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;年龄       学号       姓名  &quot;);</span><br><span class="line">		for(Student s : stus)&#123;</span><br><span class="line">			System.out.println(s.getAge()+&quot;   &quot;+s.getNum()+&quot;   &quot;+s.getName());</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
### 3、总结
总结一下，这两种比较器Comparable和Comparator，后者相比前者有如下优点：
- 个性化比较：如果实现类没有实现Comparable接口，又想对两个类进行比较（或者实现类实现了Comparable接口，但是对compareTo方法内的比较算法不满意），那么可以实现Comparator接口，自定义一个比较器，写比较算法。
- 解耦：实现Comparable接口的方式比实现Comparator接口的耦合性要强一些，如果要修改比较算法，要修改Comparable接口的实现类，而实现Comparator的类是在外部进行比较的，不需要对实现类有任何修改。从这个角度说，其实有些不太好，尤其在我们将实现类的.class文件打成一个.jar文件提供给开发者使用的时候。

### 4.hasCode和equals
hasCodehe和equals用来标识对象,两个方法协同工作来判断两个对象是否相等.
Object类定义中对hasCode和equals要求如下
1. 如果两个对象的equals的结果相等的,则两个对象的hashCode的返回值记过必须是相同的.
2. 任何时候覆写equals,必须同时覆写hashCode

若两个对象的hashCode相等，则equals不一定为true。若equals为true，则两个对象的hashCode一定相等。

## 7.Map集合
Map类的特点如下:
- Map类取代了旧对象Dictionary,拥有更好的性能
- 没有重复的Key,可以有多个重复的value
- value可以是list.map.set类对象
- KV是否允许为null,一实现的类约束为准

![](easyCoding06/2.png)
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/14/easyCoding06/" data-id="ckk5bkae2000kdkgdai4t6vxw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/EasyCoding%E7%AC%94%E8%AE%B0/" rel="tag">EasyCoding笔记</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/10/16/easyCoding07/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (七)并发与多线程
        
      </div>
    </a>
  
  
    <a href="/2019/10/09/easyCoding05/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">(五)异常与日志</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/EasyCoding%E7%AC%94%E8%AE%B0/" rel="tag">EasyCoding笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lambda/" rel="tag">Lambda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PageHelper/" rel="tag">PageHelper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stream/" rel="tag">Stream</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/idea/" rel="tag">idea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">java设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/" rel="tag">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssm%E9%85%8D%E7%BD%AE/" rel="tag">ssm配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81sql/" rel="tag">动态sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" rel="tag">设计原则</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/EasyCoding%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">EasyCoding笔记</a> <a href="/tags/Lambda/" style="font-size: 10px;">Lambda</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Mybatis/" style="font-size: 15px;">Mybatis</a> <a href="/tags/PageHelper/" style="font-size: 10px;">PageHelper</a> <a href="/tags/Stream/" style="font-size: 10px;">Stream</a> <a href="/tags/idea/" style="font-size: 10px;">idea</a> <a href="/tags/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">java设计模式</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/ssm%E9%85%8D%E7%BD%AE/" style="font-size: 10px;">ssm配置</a> <a href="/tags/%E5%8A%A8%E6%80%81sql/" style="font-size: 10px;">动态sql</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" style="font-size: 10px;">设计原则</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/20/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/06/06/Mybatis-Base/">MyBatis知识点总结(一)</a>
          </li>
        
          <li>
            <a href="/2020/01/28/Lambda/">Lambda学习总结</a>
          </li>
        
          <li>
            <a href="/2020/01/27/Stream/">Stream流学习总结</a>
          </li>
        
          <li>
            <a href="/2020/01/18/Algorithm-summary/">算法总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>